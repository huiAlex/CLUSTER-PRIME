[DERBY-2631] Expose existing auto-generated key functionality through more JDBC APIs in embedded mode.  <p>Derby currently supports the following JDBC methods for auto-generated keys:</p>

<p>  // Indicate that we want to retrieve auto-generated key values.</p>

<p>  Connection.prepareStatement(String sql, int autoGeneratedKeys);<br/>
  Statement.execute(String sql, int autoGeneratedKeys);<br/>
  Statement.executeUpdate(String sql, int autoGeneratedKeys);</p>

<p>  // Retrieve the auto-generated values (only applies to INSERT statements).</p>

<p>  ResultSet rs = Statement.getGeneratedKeys();</p>

<p>The current implementation of getGeneratedKeys() internally maps to the  IDENTITY_VAL_LOCAL()  method, which means that Derby s implementation only returns generated keys for autoincrement columns (no other default columns are supported).  Further:</p>

<p>  1. The generated key result set only ever has a single column.  This is<br/>
     because Derby only allows one autoincrement column per table.</p>

<p>  2. The type of the single column in the result set will be DECIMAL(31,0).<br/>
     This is defined by IDENTITY_VAL_LOCAL().</p>

<p>  3. The generated key result set will only ever have a single row.  This is<br/>
     because IDENTITY_VAL_LOCAL() only returns values that were assigned as<br/>
     the result of a <b>single row</b> INSERT statement using a VALUES clause.<br/>
     For a single row INSERT statement, at most one autoincrement value<br/>
     will be generated.</p>

<p>All of that said, JDBC 3.0 also defines the following methods, which allow the user to explicitly indicate, via column position or column name, the columns for which the auto-generated keys should be made available:</p>

<p>  Connection.prepareStatement(String sql, String[] columnNames);<br/>
  Connection.prepareStatement(String sql, int[] columnIndexes);</p>

<p>  Statement.execute(String sql, String[] columNames);<br/>
  Statement.execute(String sql, int[] columIndexes);</p>

<p>  Statement.executeUpdate(String sql, String[] columnNames);<br/>
  Statement.executeUpdate(String sql, int[] columnIndexes);</p>

<p>Derby currently throws a  Feature not supported  error for all of these methods.  However, it seems like the above methods could be  mapped  onto the existing Derby behavior with relatively little effort (in embedded mode).  Most of the required code is already in place.</p>

<p>Doing so would make it easier for applications that rely on the columnNames and/or columnIndexes APIs to work with Derby (assuming the app just wants generated keys for identity (autoincrement) columns).</p>

<p>Note that this Jira does <b>not</b> entail removing any of the restrictions nor changing any of the behavior outlined above.  All of that will remain exactly as it is.  This Jira simply exposes the existing functionality (restrictions and all) through additional (standard) API methods. In particular this means that any column specified by index (position) or name must be an auto-increment column for the INSERT table; otherwise Derby should throw an error.  Or put differently, a user who specifies a column name/position will get-<del>in the absence of errors</del>-the <b>exact</b> same results as s/he would get from invoking the  (String sql, int autoGeneratedKeys)  method.</p>

<p>Note also: This Jira is specifically for embedded mode.  I think it would be harder to support these methods for Derby Client and so do not plan to address that.</p> 
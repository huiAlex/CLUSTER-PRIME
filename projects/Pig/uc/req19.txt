[PIG-1077] [Zebra] to support record(row)-based file split in Zebra s TableInputFormat <p>TFile currently supports split by record sequence number (see Jira <a href= https://issues.apache.org/jira/browse/HADOOP-6218  title= Split TFile by Record Sequence Number  class= issue-link  data-issue-key= HADOOP-6218 ><del>HADOOP-6218</del></a>). We want to utilize this to provide record(row)-based input split support in Zebra.<br/>
One prominent benefit is that: in cases where we have very large data files, we can create much more fine-grained input splits than before where we can only create one big split for one big file.</p>

<p>In more detail, the new row-based getSplits() works by default (user does not specify no. of splits to be generated) as follows: <br/>
1) Select the biggest column group in terms of data size, split all of its TFiles according to hdfs block size (64 MB or 128 MB) and get a list of physical byte offsets as the output per TFile. For example, let us assume for the 1st TFile we get offset1, offset2, ..., offset10; <br/>
2) Invoke TFile.getRecordNumNear(long offset) to get the RecordNum of a key-value pair near a byte offset. For the example above, say we get recordNum1, recordNum2, ..., recordNum10; <br/>
3) Stitch <span class= error >&#91;0, recordNum1&#93;</span>, <span class= error >&#91;recordNum1+1, recordNum2&#93;</span>, ..., <span class= error >&#91;recordNum9+1, recordNum10&#93;</span>, <span class= error >&#91;recordNum10+1, lastRecordNum&#93;</span> splits of all column groups, respectively to form 11 record-based input splits for the 1st TFile. <br/>
4) For each input split, we need to create a TFile scanner through: TFile.createScannerByRecordNum(long beginRecNum, long endRecNum). </p>

<p>Note: conversion from byte offset to record number will be done by each mapper, rather than being done at the job initialization phase. This is due to performance concern since the conversion incurs some TFile reading overhead.</p>